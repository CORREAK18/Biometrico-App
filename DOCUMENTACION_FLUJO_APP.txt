â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        DOCUMENTACIÃ“N TÃ‰CNICA - APLICACIÃ“N DE RECONOCIMIENTO FACIAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ ÃNDICE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Arquitectura General
2. Archivos de la Carpeta DATA - Â¿CuÃ¡les son Ãºtiles?
3. Flujo COMPLETO: Registrar Rostro
4. Flujo COMPLETO: Reconocer Rostro
5. Flujo COMPLETO: Listar Registrados
6. TecnologÃ­as Utilizadas
7. CÃ³mo Funciona el Reconocimiento Facial (Detalles TÃ©cnicos)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. ARQUITECTURA GENERAL DE LA APLICACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

La aplicaciÃ³n sigue el patrÃ³n MVVM (Model-View-ViewModel) con arquitectura limpia:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          CAPAS DE LA APLICACIÃ“N                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  UI (Jetpack Compose)                                                   â”‚
â”‚  â”œâ”€â”€ HomeScreen.kt           â†’ Pantalla principal con 3 botones        â”‚
â”‚  â”œâ”€â”€ RegisterScreen.kt       â†’ Captura foto + datos para registrar     â”‚
â”‚  â”œâ”€â”€ RecognizeScreen.kt      â†’ Captura foto y busca coincidencias      â”‚
â”‚  â”œâ”€â”€ ViewAllScreen.kt        â†’ Muestra todos los rostros registrados   â”‚
â”‚  â””â”€â”€ CameraScreen.kt         â†’ Componente de cÃ¡mara (CameraX)          â”‚
â”‚           â†“                                                             â”‚
â”‚  VIEWMODEL (LÃ³gica de negocio)                                         â”‚
â”‚  â””â”€â”€ FaceViewModel.kt        â†’ Gestiona estados y lÃ³gica de la app     â”‚
â”‚           â†“                                                             â”‚
â”‚  REPOSITORY (AbstracciÃ³n de datos)                                     â”‚
â”‚  â””â”€â”€ FaceRepository.kt       â†’ Intermediario entre ViewModel y BD      â”‚
â”‚           â†“                                                             â”‚
â”‚  DATA (Acceso a datos)                                                 â”‚
â”‚  â”œâ”€â”€ FaceDao.kt              â†’ Consultas SQL (CRUD)                    â”‚
â”‚  â”œâ”€â”€ FaceDatabase.kt         â†’ ConfiguraciÃ³n de Room (SQLite)          â”‚
â”‚  â””â”€â”€ FaceEntity.kt           â†’ Modelo de datos (tabla faces)           â”‚
â”‚           â†“                                                             â”‚
â”‚  ML (Machine Learning)                                                  â”‚
â”‚  â””â”€â”€ FaceRecognitionProcessorMejorado.kt â†’ DetecciÃ³n + Reconocimiento â”‚
â”‚           â†“                                                             â”‚
â”‚  UTILS (Utilidades)                                                    â”‚
â”‚  â””â”€â”€ ImageUtils.kt           â†’ ConversiÃ³n de imÃ¡genes                  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
2. ARCHIVOS DE LA CARPETA DATA - Â¿CUÃLES SON ÃšTILES?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

En la carpeta 'data/' hay 4 archivos. TODOS SON ÃšTILES Y NECESARIOS:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Archivo                  â”‚ Â¿Se Usa? â”‚ PropÃ³sito                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FaceEntity.kt            â”‚ âœ… SÃ    â”‚ Define la estructura de datos  â”‚
â”‚                          â”‚          â”‚ (tabla 'faces' en SQLite)      â”‚
â”‚                          â”‚          â”‚ Campos: id, dni, nombre,       â”‚
â”‚                          â”‚          â”‚ faceImage, faceEmbedding       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FaceDao.kt               â”‚ âœ… SÃ    â”‚ Interface con consultas SQL    â”‚
â”‚                          â”‚          â”‚ (Insert, Select, Delete)       â”‚
â”‚                          â”‚          â”‚ Usado por Repository           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FaceDatabase.kt          â”‚ âœ… SÃ    â”‚ ConfiguraciÃ³n de Room          â”‚
â”‚                          â”‚          â”‚ (SQLite). PatrÃ³n Singleton     â”‚
â”‚                          â”‚          â”‚ Provee acceso a FaceDao        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ FaceRepository.kt        â”‚ âœ… SÃ    â”‚ Intermediario entre ViewModel  â”‚
â”‚                          â”‚          â”‚ y la base de datos             â”‚
â”‚                          â”‚          â”‚ Abstrae la lÃ³gica de acceso    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CONCLUSIÃ“N: Los 4 archivos son NECESARIOS y estÃ¡n siendo usados activamente.

Flujo de uso:
  ViewModel â†’ FaceRepository â†’ FaceDao â†’ FaceDatabase â†’ SQLite


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
3. FLUJO COMPLETO: REGISTRAR ROSTRO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PASO 1: Usuario presiona "Registrar Rostro" en HomeScreen
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: HomeScreen.kt
ğŸ“ LÃ­nea: onClick del botÃ³n "â• Registrar Rostro"
ğŸ”§ AcciÃ³n: navController.navigate(Screen.Register.route)
ğŸ“¤ Resultado: Navega a RegisterScreen


PASO 2: Se abre RegisterScreen (pantalla de registro)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: RegisterScreen.kt
ğŸ“ Componentes:
   - Campo de texto para DNI
   - Campo de texto para Nombre
   - Ãrea circular para mostrar foto capturada
   - BotÃ³n "Abrir CÃ¡mara"
   - BotÃ³n "Registrar"


PASO 3: Usuario presiona "Abrir CÃ¡mara"
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: RegisterScreen.kt
ğŸ“ LÃ­nea: showCamera = true
ğŸ”§ AcciÃ³n: Solicita permiso de cÃ¡mara y abre CameraScreen
ğŸ“¤ Resultado: Se muestra el preview de la cÃ¡mara


PASO 4: Usuario captura foto en CameraScreen
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: CameraScreen.kt
ğŸ”§ TecnologÃ­a: CameraX (androidx.camera)
ğŸ“ Proceso:
   1. Inicializa cameraProvider
   2. Configura ImageCapture
   3. Al presionar botÃ³n captura:
      - Toma foto con imageCapture.takePicture()
      - Convierte ImageProxy a Bitmap
      - Rota la imagen si es necesario
ğŸ”™ Callback: onImageCaptured(bitmap)
ğŸ“¤ Resultado: Vuelve a RegisterScreen con la imagen capturada


PASO 5: Usuario ingresa DNI y Nombre, luego presiona "Registrar"
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: RegisterScreen.kt
ğŸ“ LÃ­nea: onClick del botÃ³n "Registrar"
ğŸ”§ AcciÃ³n: viewModel.registerFace(capturedImage!!, dni, nombre)


PASO 6: FaceViewModel procesa el registro
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: FaceViewModel.kt
ğŸ“ FunciÃ³n: registerFace(bitmap, dni, nombre)
ğŸ“‹ Proceso detallado:

   6.1 Cambia estado a "Processing"
       _registrationState.value = RegistrationState.Processing

   6.2 VALIDACIÃ“N 1: Verifica DNI duplicado
       val existingFace = repository.getFaceByDni(dni)
       â†“
       ğŸ“‚ FaceRepository.kt â†’ getFaceByDni(dni)
       â†“
       ğŸ“‚ FaceDao.kt â†’ Query SQL: SELECT * FROM faces WHERE dni = :dni

       Si existe â†’ Error: "DNI ya registrado"

   6.3 VALIDACIÃ“N 2: Detecta rostros en la imagen
       val faces = faceProcessor.detectFaces(bitmap)
       â†“
       ğŸ“‚ FaceRecognitionProcessorMejorado.kt
       ğŸ“ FunciÃ³n: detectFaces(bitmap)
       ğŸ”§ TecnologÃ­a: ML Kit Face Detection (Google)

       Proceso interno:
       - Convierte Bitmap a InputImage
       - Usa detector.process(image)
       - ML Kit analiza la imagen y busca rostros
       - Retorna lista de objetos Face con landmarks y Ã¡ngulos

       Validaciones:
       - Si faces.isEmpty() â†’ Error: "No se detectÃ³ rostro"
       - Si faces.size > 1 â†’ Error: "MÃºltiples rostros detectados"

   6.4 Extrae caracterÃ­sticas faciales (EMBEDDING)
       val embedding = faceProcessor.extractFaceEmbedding(face, bitmap)
       â†“
       ğŸ“‚ FaceRecognitionProcessorMejorado.kt
       ğŸ“ FunciÃ³n: extractFaceEmbedding(face, bitmap)

       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  CAJA NEGRA: GeneraciÃ³n de Vector de CaracterÃ­sticas   â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â”‚  ENTRADA:                                               â”‚
       â”‚    - Face object (landmarks, Ã¡ngulos de rotaciÃ³n, etc.) â”‚
       â”‚    - Bitmap (imagen del rostro)                         â”‚
       â”‚                                                         â”‚
       â”‚  PROCESO INTERNO (250 dimensiones):                     â”‚
       â”‚    1. Extrae 12 landmarks (ojos, nariz, boca, etc.)     â”‚
       â”‚    2. Calcula 6 dimensiones bÃ¡sicas del rostro          â”‚
       â”‚    3. Calcula 48 posiciones (absolutas + relativas)     â”‚
       â”‚    4. Calcula 40 distancias entre landmarks             â”‚
       â”‚    5. Calcula 20 Ã¡ngulos entre landmarks                â”‚
       â”‚    6. Calcula 30 ratios y proporciones faciales         â”‚
       â”‚    7. Agrega 6 Ã¡ngulos de rotaciÃ³n de cabeza            â”‚
       â”‚    8. Agrega 6 valores de expresiones faciales          â”‚
       â”‚    9. Calcula 40 caracterÃ­sticas derivadas avanzadas    â”‚
       â”‚   10. Calcula 30 distancias cruzadas adicionales        â”‚
       â”‚   11. Calcula 24 Ã¡ngulos complejos adicionales          â”‚
       â”‚   12. Normaliza todo el vector a magnitud 1             â”‚
       â”‚                                                         â”‚
       â”‚  SALIDA:                                                â”‚
       â”‚    FloatArray de ~250 nÃºmeros                           â”‚
       â”‚    Ejemplo: [0.023, 0.154, 0.089, ..., 0.456, 0.123]   â”‚
       â”‚                                                         â”‚
       â”‚  Este vector es la "huella digital" Ãºnica del rostro    â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   6.5 Prepara datos para almacenamiento
       - Escala imagen: ImageUtils.scaleBitmap(bitmap)
       - Convierte Bitmap a ByteArray: ImageUtils.bitmapToByteArray()
       - Convierte FloatArray a ByteArray: ImageUtils.floatArrayToByteArray()

   6.6 Crea entidad y guarda en base de datos
       val faceEntity = FaceEntity(
           dni = dni,
           nombre = nombre,
           faceImage = imageBytes,
           faceEmbedding = embeddingBytes
       )

       repository.insertFace(faceEntity)
       â†“
       ğŸ“‚ FaceRepository.kt â†’ insertFace(faceEntity)
       â†“
       ğŸ“‚ FaceDao.kt â†’ @Insert suspend fun insertFace(face: FaceEntity)
       â†“
       ğŸ“‚ FaceDatabase.kt â†’ Room ejecuta INSERT INTO faces
       â†“
       ğŸ’¾ SQLite: Se guarda en la base de datos local

   6.7 Actualiza estado a "Success"
       _registrationState.value = RegistrationState.Success("âœ“ Rostro registrado")


PASO 7: RegisterScreen reacciona al estado
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: RegisterScreen.kt
ğŸ“ LaunchedEffect observa registrationState
ğŸ”§ AcciÃ³n:
   - Muestra mensaje de Ã©xito por 2 segundos
   - Resetea el estado
   - Navega de vuelta a HomeScreen


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
4. FLUJO COMPLETO: RECONOCER ROSTRO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PASO 1: Usuario presiona "Reconocer Rostro" en HomeScreen
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: HomeScreen.kt
ğŸ“ LÃ­nea: onClick del botÃ³n "ğŸ” Reconocer Rostro"
ğŸ”§ AcciÃ³n: navController.navigate(Screen.Recognize.route)
ğŸ“¤ Resultado: Navega a RecognizeScreen


PASO 2: Se abre RecognizeScreen
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: RecognizeScreen.kt
ğŸ“ Componentes:
   - Ãrea para mostrar foto capturada
   - BotÃ³n "Abrir CÃ¡mara"
   - Card para mostrar resultado del reconocimiento


PASO 3: Usuario presiona "Abrir CÃ¡mara" y captura foto
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: RecognizeScreen.kt â†’ CameraScreen.kt
ğŸ”§ Proceso: (Igual que en registro)
ğŸ”™ Callback: onImageCaptured = { bitmap ->
                capturedImage = bitmap
                viewModel.recognizeFace(bitmap)  â† LLAMA RECONOCIMIENTO
             }


PASO 4: FaceViewModel procesa el reconocimiento
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: FaceViewModel.kt
ğŸ“ FunciÃ³n: recognizeFace(bitmap)
ğŸ“‹ Proceso detallado:

   4.1 Detecta rostro en la imagen
       val faces = faceProcessor.detectFaces(bitmap)

       Validaciones:
       - Si faces.isEmpty() â†’ "No se detectÃ³ rostro"
       - Si faces.size > 1 â†’ "MÃºltiples rostros detectados"

   4.2 Extrae embedding del rostro capturado
       val queryEmbedding = faceProcessor.extractFaceEmbedding(face, bitmap)

       â†“ Genera vector de 250 nÃºmeros (igual que en registro)

   4.3 Obtiene todos los rostros registrados de la BD
       val allFacesData = _allFaces.value

       (Este StateFlow se actualiza automÃ¡ticamente desde la BD)

   4.4 Prepara lista de candidatos
       val candidates = allFacesData.map { faceEntity ->
           val embedding = ImageUtils.byteArrayToFloatArray(faceEntity.faceEmbedding)
           Pair(faceEntity.id, embedding)
       }

       Resultado: Lista de pares (ID, Vector250D) de cada persona registrada

   4.5 Busca la mejor coincidencia
       val bestMatch = faceProcessor.findBestMatch(
           queryEmbedding,
           candidates,
           threshold = 0.80f  â† UMBRAL DE CONFIANZA: 80%
       )
       â†“
       ğŸ“‚ FaceRecognitionProcessorMejorado.kt
       ğŸ“ FunciÃ³n: findBestMatch()

       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  CAJA NEGRA: BÃºsqueda de Mejor Coincidencia            â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â”‚  ENTRADA:                                               â”‚
       â”‚    - queryEmbedding: Vector de 250 nÃºmeros (rostro      â”‚
       â”‚      capturado)                                         â”‚
       â”‚    - candidates: Lista de vectores de 250 nÃºmeros       â”‚
       â”‚      (rostros registrados)                              â”‚
       â”‚    - threshold: 0.80 (80% de confianza mÃ­nima)          â”‚
       â”‚                                                         â”‚
       â”‚  PROCESO INTERNO:                                       â”‚
       â”‚    Para cada candidato:                                 â”‚
       â”‚      1. Calcula similitud coseno:                       â”‚
       â”‚         similarity = calculateSimilarity(queryEmbedding,â”‚
       â”‚                                          candidateEmbed)â”‚
       â”‚                                                         â”‚
       â”‚         FÃ³rmula:                                        â”‚
       â”‚         dotProduct = A[0]*B[0] + A[1]*B[1] + ... +      â”‚
       â”‚                      A[249]*B[249]                      â”‚
       â”‚         similarity = (dotProduct + 1) / 2               â”‚
       â”‚                                                         â”‚
       â”‚      2. Si similarity > bestSimilarity:                 â”‚
       â”‚            Actualiza bestMatch = (id, similarity)       â”‚
       â”‚                                                         â”‚
       â”‚  INTERPRETACIÃ“N DE SIMILITUD:                           â”‚
       â”‚    1.00 (100%) â†’ IdÃ©nticos (mismo rostro)               â”‚
       â”‚    0.85 (85%)  â†’ Muy similares (probablemente mismo)    â”‚
       â”‚    0.80 (80%)  â†’ Umbral mÃ­nimo (aceptado)               â”‚
       â”‚    0.75 (75%)  â†’ Similares (RECHAZADO - bajo umbral)    â”‚
       â”‚    0.60 (60%)  â†’ Algo parecidos (RECHAZADO)             â”‚
       â”‚    0.40 (40%)  â†’ Diferentes (RECHAZADO)                 â”‚
       â”‚                                                         â”‚
       â”‚  SALIDA:                                                â”‚
       â”‚    - Si encuentra match >= 80%: Pair(id, similarity)    â”‚
       â”‚    - Si no hay match >= 80%: null                       â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   4.6 Procesa el resultado
       Si bestMatch != null:
           - Busca el FaceEntity correspondiente al ID
           - Crea RecognitionResult con:
               found = true
               name = matchedFace.nombre
               dni = matchedFace.dni
               similarity = bestMatch.second
               message = "âœ“ Rostro reconocido con 85% de confianza"

       Si bestMatch == null:
           RecognitionResult(
               found = false,
               message = "âœ— Rostro no reconocido. Similitud < 80%"
           )

   4.7 Actualiza el estado
       _recognitionResult.value = result


PASO 5: RecognizeScreen muestra el resultado
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: RecognizeScreen.kt
ğŸ“ Observa recognitionResult StateFlow
ğŸ”§ Muestra:
   Si found = true:
       - Card verde con Ã­cono âœ“
       - Nombre de la persona
       - DNI
       - Porcentaje de confianza

   Si found = false:
       - Card roja con Ã­cono âœ—
       - Mensaje de error


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5. FLUJO COMPLETO: LISTAR REGISTRADOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PASO 1: Usuario presiona "Ver Registrados" en HomeScreen
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: HomeScreen.kt
ğŸ“ LÃ­nea: onClick del botÃ³n "ğŸ“‹ Ver Registrados"
ğŸ”§ AcciÃ³n: navController.navigate(Screen.ViewAll.route)
ğŸ“¤ Resultado: Navega a ViewAllScreen


PASO 2: ViewAllScreen se inicializa
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: ViewAllScreen.kt
ğŸ“ Observa: val allFaces by viewModel.allFaces.collectAsState()


PASO 3: FaceViewModel mantiene lista actualizada
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: FaceViewModel.kt
ğŸ“ Bloque init:

   viewModelScope.launch {
       repository.allFaces.collect { faces â†’
           _allFaces.value = faces
       }
   }

   Flujo de datos:
   â†“
   ğŸ“‚ FaceRepository.kt
   ğŸ“ val allFaces: Flow<List<FaceEntity>> = faceDao.getAllFaces()
   â†“
   ğŸ“‚ FaceDao.kt
   ğŸ“ @Query("SELECT * FROM faces")
      fun getAllFaces(): Flow<List<FaceEntity>>
   â†“
   ğŸ“‚ FaceDatabase.kt (Room ejecuta query)
   â†“
   ğŸ’¾ SQLite: SELECT * FROM faces
   â†“
   ğŸ”„ Room convierte resultados a List<FaceEntity>
   â†“
   ğŸ”„ Flow emite actualizaciones automÃ¡ticas cuando hay cambios en BD


PASO 4: ViewAllScreen renderiza la lista
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: ViewAllScreen.kt
ğŸ“ Componente: LazyColumn

   Para cada FaceEntity en allFaces:
       - Convierte faceImage (ByteArray) a Bitmap
       - Muestra en un Card:
           â”œâ”€â”€ Foto circular del rostro
           â”œâ”€â”€ Nombre de la persona
           â”œâ”€â”€ DNI
           â”œâ”€â”€ Fecha de registro
           â””â”€â”€ BotÃ³n "Eliminar" (icono de basura)


PASO 5: Usuario presiona botÃ³n "Eliminar" en un registro
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: ViewAllScreen.kt
ğŸ“ onClick del IconButton(Delete)
ğŸ”§ AcciÃ³n:
   1. Muestra AlertDialog de confirmaciÃ³n
   2. Si usuario confirma:
      viewModel.deleteFace(id)
      â†“
      ğŸ“‚ FaceViewModel.kt
      ğŸ“ FunciÃ³n: deleteFace(id)

      viewModelScope.launch {
          repository.deleteFaceById(id)
      }
      â†“
      ğŸ“‚ FaceRepository.kt â†’ deleteFaceById(id)
      â†“
      ğŸ“‚ FaceDao.kt
      ğŸ“ @Query("DELETE FROM faces WHERE id = :id")
      â†“
      ğŸ’¾ SQLite: DELETE FROM faces WHERE id = 5
      â†“
      ğŸ”„ Room notifica cambio en la BD
      â†“
      ğŸ”„ Flow en allFaces emite nueva lista (sin el eliminado)
      â†“
      ğŸ”„ ViewAllScreen se actualiza automÃ¡ticamente (recompose)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
6. TECNOLOGÃAS UTILIZADAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TecnologÃ­a                    â”‚ PropÃ³sito                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Kotlin                        â”‚ Lenguaje de programaciÃ³n           â”‚
â”‚ Jetpack Compose               â”‚ UI moderna declarativa             â”‚
â”‚ Room Database                 â”‚ ORM para SQLite (base de datos)    â”‚
â”‚ CameraX                       â”‚ Captura de imÃ¡genes con cÃ¡mara     â”‚
â”‚ ML Kit Face Detection         â”‚ DetecciÃ³n de rostros (Google)      â”‚
â”‚ Coroutines + Flow             â”‚ ProgramaciÃ³n asÃ­ncrona             â”‚
â”‚ ViewModel + StateFlow         â”‚ GestiÃ³n de estados (MVVM)          â”‚
â”‚ Navigation Compose            â”‚ NavegaciÃ³n entre pantallas         â”‚
â”‚ Accompanist Permissions       â”‚ Manejo de permisos de Android      â”‚
â”‚ Coil                          â”‚ Carga de imÃ¡genes                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
7. CÃ“MO FUNCIONA EL RECONOCIMIENTO FACIAL (DETALLES TÃ‰CNICOS)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  PROCESO DE RECONOCIMIENTO FACIAL                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ETAPA 1: DETECCIÃ“N DE ROSTRO (ML Kit)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ TecnologÃ­a: ML Kit Face Detection de Google
ğŸ”§ QuÃ© hace:
   - Analiza la imagen pixel por pixel
   - Identifica regiones que parecen caras humanas
   - Detecta 12 landmarks (puntos clave):
       â”œâ”€â”€ Ojo izquierdo
       â”œâ”€â”€ Ojo derecho
       â”œâ”€â”€ Base de la nariz
       â”œâ”€â”€ Boca izquierda
       â”œâ”€â”€ Boca derecha
       â”œâ”€â”€ Boca inferior
       â”œâ”€â”€ Mejilla izquierda
       â”œâ”€â”€ Mejilla derecha
       â”œâ”€â”€ Oreja izquierda
       â””â”€â”€ Oreja derecha
   - Calcula Ã¡ngulos de rotaciÃ³n de la cabeza (Euler angles)
   - Estima probabilidades de expresiones (sonrisa, ojos abiertos)

ğŸ“¤ Output: Objeto Face con:
   - boundingBox (rectÃ¡ngulo del rostro)
   - landmarks (12 puntos)
   - headEulerAngleX, Y, Z (rotaciÃ³n)
   - smilingProbability
   - leftEyeOpenProbability
   - rightEyeOpenProbability


ETAPA 2: EXTRACCIÃ“N DE CARACTERÃSTICAS (Procesador Mejorado)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: FaceRecognitionProcessorMejorado.kt
ğŸ“ FunciÃ³n: extractFaceEmbedding()
ğŸ”§ TecnologÃ­a: GeometrÃ­a pura (NO usa redes neuronales)

Â¿POR QUÃ‰ NO USA FACENET O ARCFACE?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FaceNet, MobileFaceNet, ArcFace son modelos de Deep Learning que:
  - Requieren TensorFlow Lite o PyTorch Mobile
  - Necesitan archivos .tflite pesados (5-20 MB)
  - Usan GPU para inferencia rÃ¡pida
  - Generan embeddings de 128/512 dimensiones con CNN

Esta app usa un ENFOQUE GEOMÃ‰TRICO:
  - Solo calcula distancias, Ã¡ngulos y proporciones
  - NO necesita modelos pre-entrenados
  - MÃ¡s liviano (sin archivos extras)
  - Suficientemente preciso para casos bÃ¡sicos

PROCESO DE EXTRACCIÃ“N (250 DIMENSIONES):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Vector[0-5]: Dimensiones bÃ¡sicas del rostro
  - Ancho del rostro / 1000
  - Alto del rostro / 1000
  - Ratio ancho/alto
  - Ãrea del rostro / 1000000
  - PosiciÃ³n X
  - PosiciÃ³n Y

Vector[6-29]: Posiciones absolutas de landmarks (X, Y de cada uno)
  - leftEye.x / 1000, leftEye.y / 1000
  - rightEye.x / 1000, rightEye.y / 1000
  - noseBase.x / 1000, noseBase.y / 1000
  - ... (12 landmarks Ã— 2 coordenadas = 24 valores)

Vector[30-53]: Posiciones relativas normalizadas
  - (leftEye.x - faceCenterX) / faceWidth
  - (leftEye.y - faceCenterY) / faceHeight
  - ... (12 landmarks Ã— 2 = 24 valores)

Vector[54-93]: Distancias entre landmarks (40 valores)
  - distance(leftEye, rightEye) / faceWidth
  - distance(leftEye, noseBase) / faceWidth
  - distance(rightEye, noseBase) / faceWidth
  - distance(leftEye, mouthLeft) / faceWidth
  - ... (40 distancias diferentes)

Vector[94-113]: Ãngulos entre landmarks (20 valores)
  - atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x) / Ï€
  - atan2(nose.y - centerY, nose.x - centerX) / Ï€
  - Ãngulos de triÃ¡ngulos formados por landmarks
  - ... (20 Ã¡ngulos diferentes)

Vector[114-143]: Ratios y proporciones faciales (30 valores)
  - eyeDistance / faceWidth
  - mouthWidth / faceWidth
  - mouthWidth / eyeDistance
  - SimetrÃ­as izquierda/derecha
  - cheekDistance / faceWidth
  - earDistance / faceWidth
  - ... (30 proporciones)

Vector[144-149]: Ãngulos de rotaciÃ³n de cabeza (6 valores)
  - headEulerAngleX / 90
  - (headEulerAngleX)Â² / 8100
  - headEulerAngleY / 90
  - (headEulerAngleY)Â² / 8100
  - headEulerAngleZ / 90
  - (headEulerAngleZ)Â² / 8100

Vector[150-155]: Expresiones faciales (6 valores)
  - smilingProbability
  - leftEyeOpenProbability
  - rightEyeOpenProbability
  - Promedio de apertura de ojos
  - Diferencia entre ojos
  - ExpresiÃ³n combinada

Vector[156-250]: CaracterÃ­sticas derivadas avanzadas (~94 valores)
  - Cuadrantes del rostro
  - Densidad de landmarks
  - Distancias cruzadas adicionales
  - Ãngulos complejos adicionales

NORMALIZACIÃ“N FINAL:
  - Se calcula la magnitud del vector:
    magnitude = âˆš(v[0]Â² + v[1]Â² + ... + v[249]Â²)
  - Se divide cada componente por la magnitud:
    normalizedVector[i] = vector[i] / magnitude
  - Esto asegura que el vector tenga longitud 1

ğŸ“¤ Output: FloatArray de ~250 nÃºmeros normalizados


ETAPA 3: COMPARACIÃ“N DE VECTORES (Similitud Coseno)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: FaceRecognitionProcessorMejorado.kt
ğŸ“ FunciÃ³n: calculateSimilarity()

FÃ“RMULA DE SIMILITUD COSENO:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Sean A y B dos vectores de 250 dimensiones:

A = [aâ‚€, aâ‚, aâ‚‚, ..., aâ‚‚â‚„â‚‰]  â† Rostro capturado
B = [bâ‚€, bâ‚, bâ‚‚, ..., bâ‚‚â‚„â‚‰]  â† Rostro registrado

Producto punto:
  dotProduct = aâ‚€Ã—bâ‚€ + aâ‚Ã—bâ‚ + aâ‚‚Ã—bâ‚‚ + ... + aâ‚‚â‚„â‚‰Ã—bâ‚‚â‚„â‚‰

Como los vectores estÃ¡n normalizados (magnitud = 1):
  dotProduct âˆˆ [-1, 1]

ConversiÃ³n a rango [0, 1]:
  similarity = (dotProduct + 1) / 2

INTERPRETACIÃ“N:
  similarity = 1.0 â†’ Vectores idÃ©nticos (100% iguales)
  similarity = 0.9 â†’ Muy similares (90% iguales)
  similarity = 0.8 â†’ Similares (80% iguales) â† UMBRAL MÃNIMO
  similarity = 0.7 â†’ Algo parecidos (70%)
  similarity = 0.5 â†’ Diferentes (50%)
  similarity = 0.0 â†’ Totalmente opuestos (0%)

Â¿POR QUÃ‰ FUNCIONA?
  Si dos personas tienen caracterÃ­sticas faciales similares:
    - Distancia entre ojos parecida â†’ aâ‚…â‚„ â‰ˆ bâ‚…â‚„
    - Ãngulo de nariz parecido â†’ aâ‚‰â‚„ â‰ˆ bâ‚‰â‚„
    - Ratio boca/cara parecido â†’ aâ‚â‚â‚„ â‰ˆ bâ‚â‚â‚„
    - ... y asÃ­ con las 250 dimensiones

  Entonces: aâ‚€Ã—bâ‚€ + aâ‚Ã—bâ‚ + ... serÃ¡ GRANDE

  Si son personas diferentes, muchos valores no coinciden:
  Entonces: el producto punto serÃ¡ PEQUEÃ‘O


ETAPA 4: BÃšSQUEDA DEL MEJOR MATCH
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‚ Archivo: FaceRecognitionProcessorMejorado.kt
ğŸ“ FunciÃ³n: findBestMatch()

ALGORITMO:
  1. Inicializar bestSimilarity = 0.80 (umbral)
  2. Para cada rostro registrado en la base de datos:
       a. similarity = calculateSimilarity(queryVector, candidateVector)
       b. Si similarity > bestSimilarity:
            bestSimilarity = similarity
            bestMatch = (rostroID, similarity)
  3. Retornar bestMatch (o null si nadie superÃ³ el umbral)

EJEMPLO PRÃCTICO:
  Rostros registrados:
    - Juan (ID=1): similarity = 0.65 â†’ RECHAZADO (< 0.80)
    - MarÃ­a (ID=2): similarity = 0.87 â†’ ACEPTADO âœ“
    - Pedro (ID=3): similarity = 0.72 â†’ RECHAZADO (< 0.80)

  Resultado: bestMatch = (2, 0.87) â†’ "MarÃ­a con 87% de confianza"


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
AJUSTES DE CONFIGURACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‚ Archivo: FaceViewModel.kt
ğŸ“ LÃ­nea: companion object

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Constante                â”‚ Valor Actual â”‚ PropÃ³sito              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ RECOGNITION_THRESHOLD    â”‚ 0.80f (80%)  â”‚ Confianza mÃ­nima para  â”‚
â”‚                          â”‚              â”‚ reconocer un rostro    â”‚
â”‚                          â”‚              â”‚                        â”‚
â”‚ DUPLICATE_THRESHOLD      â”‚ 0.90f (90%)  â”‚ Confianza para detectarâ”‚
â”‚                          â”‚              â”‚ rostros duplicados     â”‚
â”‚                          â”‚              â”‚ (no usado actualmente) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SI QUIERES AJUSTAR LA SENSIBILIDAD:
  - Aumentar RECOGNITION_THRESHOLD (ej: 0.85) â†’ MÃS ESTRICTO
    (Menos falsos positivos, pero puede rechazar al usuario legÃ­timo)

  - Disminuir RECOGNITION_THRESHOLD (ej: 0.75) â†’ MÃS FLEXIBLE
    (MÃ¡s probabilidad de reconocer, pero tambiÃ©n mÃ¡s falsos positivos)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RESUMEN DE ARCHIVOS CLAVE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Archivo                            â”‚ Responsabilidad               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MainActivity.kt                    â”‚ Punto de entrada de la app    â”‚
â”‚ AppNavigation.kt                   â”‚ Control de navegaciÃ³n         â”‚
â”‚ FaceViewModel.kt                   â”‚ LÃ³gica de negocio principal   â”‚
â”‚ FaceRecognitionProcessorMejorado   â”‚ Motor de reconocimiento       â”‚
â”‚ FaceRepository.kt                  â”‚ AbstracciÃ³n de datos          â”‚
â”‚ FaceDao.kt                         â”‚ Consultas SQL                 â”‚
â”‚ FaceDatabase.kt                    â”‚ ConfiguraciÃ³n de Room         â”‚
â”‚ FaceEntity.kt                      â”‚ Modelo de datos               â”‚
â”‚ HomeScreen.kt                      â”‚ Pantalla principal            â”‚
â”‚ RegisterScreen.kt                  â”‚ Pantalla de registro          â”‚
â”‚ RecognizeScreen.kt                 â”‚ Pantalla de reconocimiento    â”‚
â”‚ ViewAllScreen.kt                   â”‚ Pantalla de listado           â”‚
â”‚ CameraScreen.kt                    â”‚ Componente de cÃ¡mara          â”‚
â”‚ ImageUtils.kt                      â”‚ ConversiÃ³n de imÃ¡genes        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                              FIN DE LA DOCUMENTACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Creado: 2025-10-29
VersiÃ³n: 1.0
Proyecto: Reconocimiento Facial Android

